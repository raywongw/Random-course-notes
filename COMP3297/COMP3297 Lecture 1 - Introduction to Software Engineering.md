
[[COMP3297 Lecture 2 - Software Process Models|Next Slide]]
## Software Engineering

- Dealing with systems
	- big and complex
	- built by teams
	- for other users -> for other domains
	- used and maintained many years
	- modified many times during lifetime

## Traditional way
- Planning with throughout specification
- Small products would require too much work done
- Imperfect knowledge at start -> rework is needed


## Agile Process
- Lightweight approach
- Flexible plans and documentation
	- Document what needs to be documented
	- Put more focus on software
- Deliver product to customer quickly
	- Can get feedback from customer quickly
	- Refine the software and get to future versions
- Deliver valuables and avoid working on invaluables

| Individuals and interactions | over processes and tools         |
| ---------------------------- | -------------------------------- |
| Working software             | over comprehensive documentation |
| Customer collaboration       | over contract negotiation        |
| Responding to change         | over following a plan            |
- Focus on left more than right

## What makes software development different
- Easy to create, hard to create good products
	- Poorly designed products, hard to maintain
	- Easy to destroy good product with bad modification
- Software decline
	- Software get worse over time
	- More complex, more dependencies
	- At a point the system cannot be changed safely
- Large and Complex systems
	- Difficult to understand impact of one component on whole system



## Software Process Model
- set of activities and the way those activities are structured to develop a software product

Two aspects:
- Defines activities
- Specifies how things are organized to a workflow

Objective of the process
- Transform users' true needs to software system(s) that satisfies their needs

### General steps in technical project

#### Software Specification
Analyse the problem domain and users' needs, specify what is required to satisfy that need

- aka Requirement Engineering
- To understand and define
	- What services the system must provide
	- What constraints are there on system's operation and development
- High cost of mistakes
	- Building wrong system

###### Requirements Elicitation and Analysis
- Objective: Understand the problem and what is needed in solution
- Elicitation -> Discover stakeholders' requirements
	- Learn about the problem and define scope of system
	- Understand users tasks, goals, business objective, quality expectation
- Analyze information to be understand
	- User-facing functional requirement
	- Quality constraints on how to deliver the function
	- Relative importance of function and quality

###### Requirements Specification
Objective: document the requirements
- 

###### Requirements Validation
Objective: ensure we have specified the right system
#### Software Construction
Design and build the solution

- From Requirements to an executable system
- Design, Specify structure and data model, design implementation

#### Software Testing
- Confirm the "solution" was built correctly and really solves the users' problem

###### Component Interface Testing

###### Integration and System Testing

###### User Acceptance Testing

#### Software Evolution
- Maintain it until the end of its operational lifetime