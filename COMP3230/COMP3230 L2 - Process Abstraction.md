
[[COMP3230 L1 - Introduction|Previous Chapter]] [[COMP3230 L3 - Virtualizing the CPU|Next Chapter]]

### Process
- All application has private address space
#### Address Space
- Range of memory locations
- 32-bit system: $2^{32}$ bits of address space (4GB)
- 64-bit system: $2^{64}$ bits of address space
- Regions of Address Spaces:
##### Stack
- End of Address Space (from max address to 0)
- Local Variables, Arguments for functions

##### Heap
- Dynamically allocated memory
- After [[#Data Segment]]

##### Data Segment
- Global Variables. Static Variables
- After [[#Text Segment]]

##### Text Segment
- Program code that processor executes
- At Start of address space
- May have multiple in an address space


##### Kernel Privilege Level
- Top of Stack
- Reserved for Operating System


#### Process State
- Keep track of the current activity


##### Five States Model
- New
	- Just created
	- Not ready to run
	- Not exist in real life OS
- Running
	- A CPU is running the process
	- Spend time ranges from $10^{-9}$ s to $10^{-3}$ s
	- After descheduling a running state
- Blocked
	- Waiting for an receive event to occur
		- e.g. upon receiving message from network
- Ready
	- Waiting for free CPU resources
- Terminated
	- finished execution, waiting for cleanup
	- Check if the process is executed successfully


#### Process Control Block
- Data structure for maintaining information about process
- Process Identification Number: Unique number
- Process State
- Program Counter: Address of Next Instruction
- Register Context
	- Snapshot of register content at end of last running state
- Scheduling information
	- Process Priority
	- Pointers to scheduling queue
- Credentials
	- Resources that process can access
- Memory Management Information: Spaces allocated to this process
-  Accounting information: CPU Usage statistics, Time limit
- Pointers to child/parent process

#### Process Table
- A Map of Process ID to [[#Process Control Block]]
- for quickly killing a process (kill *PID*)
- Waste memory space

#### Process List
- Modern OS adopt this
- FIFO
- Current Queue: Per core basis
- Ready Queue: List of processes that are ready to be put at current queue
	- May have Ready List for Priority Queue
- Blocked Queue: List of Processes that are awaiting events
- List of processes in different state

##### pstree
- Linux command show relations of processes
- Process 0 - init

##### Creation of new process
- A parent process create a process
- the child can further create process and form a tree of process

##### Termination of parent process
- Child processes are maintained as independent process



##### Process Termination



##### Zombie Process
- A killed process that allow parent process to access


##### Suspend Ready State
- a suspended process 
- previously a running state or ready state
- when resumed, as a ready state


##### Suspended Blocked State
- Suspended from Blocked State



### Signals
- Notify a process that an event occured
- Implemented as system calls
	- `kill()`, `signal()`, `sigaction()`, `raise()`, `pause()`, `sigsuspend()`
- Represented by a value/symbolic name
	- SIGINT = 2 when Ctrl+C is pressed
- Generated from a software entity to a target software entity

#### Synchronous Signal
- Triggered by current instruction of current running process

##### Illegal memory access
1. A process run a illegal operation
	- dereference a `NULL` pointer
2. CPU interrupts and raise a memory protection exception
3. CPU invokes the OS Interrupt Handling routine
	- tell OS that exception occur when running a instruction
4. OS identifies causes of exception
5. OS delivers the corresponding signal (SIGSEGV) to the process X


##### Asynchronous Signals
- Generated by external events which are not triggered by current process

##### Example of Asynchronous Signal
- e.g. parent process using `kill()` to kill child process
- OS switch to kernel mode to run corresponding system function
- OS delivers `SIGKILL` signal to target process


#### Response to signal
- Process decide to **catch**, **ignore** or **mask** a signal
- `SIGKILL` and `SIGSTOP` must be done and cannot be [[#Catch|caught]]/[[#Ignore|ignored]]
##### Catch
- Uses a specific routine (Signal handler) so OS can invoke that handler when process receives signal
##### Ignore
- Inform OS that process does not want to handle signal
##### Masking
- Instruct OS not to deliver signal of that type before process clears signal mask


#### How OS determine the process that responds to a signal
- Process's [[#Process Control Block|PCB]] contains a pointer to a vector of signal handlers
- OS finds a corresponding handler in the function for the signal
- Child process inherit settings from parent




### Summary
- OS need mechanisms to keep track of current status of proceses
	- [[#Process Control Block]]
	- [[#Process Table]]
	- [[#Process List]]
- OS provides set of operation for processes
- Signals in UNIX Systems allow interactions between User mode and Kernel mode
	- Notify the processes of system events