## 6.1 Introduction to the ARM Processor family

developed by advanced RISC machine 

ARM processors is based on RISC
operates at less type of instructions
-> higher speed, lower power consumption

- first arm processor developed back in 1983-1985
- ARM6/7 developed between 1990 and 1995
- ARM8 and ARM9 in late 1990s
- Current: ARM11




## 6.2 The Datapath Design in ARM7 Processors (on which the ARMSim simulator is based)


update -> write back

##### Register Bank
- 2 read port
	- A bus and B bus

##### Barrel Shifter
- responsible for shifting bits of values


##### PC incrementer
- increment address after an instruction is loaded


##### Arithmetic and Logic Unit
- perform all arithmetic/logic operations


##### Data in/out register
- 32 bit data item
- read from main memory
- output result back to main memory


##### Instruction decoder
- decode instructions
- produce control signal to datapath

##### Data processing instruction
- read data from A bus and B bus
- 

## 6.3 The 3-Stage Pipelining in ARM7 Processors
- namely [[#Instruction Fetch (IF)|IF]], [[#Instruction Decode (ID)|ID]] and [[#Datapath Execution (EX)|EX]]
##### Instruction Fetch (IF)

##### Instruction Decode (ID)

##### Datapath Execution (EX)
- instruction is executed on datapath
- read register operand
- shift registers
- generate result by ALU
- write back to register bank
-

IF -> ID -> EX
- Intermediate result get from each stage is stored in register for next stage
	- leads to propagation delay

##### Instruction execution on Conventional sequential computer
- each stages has (t1, t2, t3) clock cycle
- time needed = t1+t2+t3

##### Instruction execution on pipelined computer
- each stages has (t1, t2, t3) clock cycle
- time needed = max(t1, t2, t3)
-> much shorter than [[#Instruction execution on Conventional sequential computer|above]]
- never reduce latency/waiting time of each individual instruction
- 

##### optimal performance
- start the opration at moddle period
- -> then nth instruction is executed at n-1th time,


### Cycle per Instruction
- Optimal is 1
- for sequential period, if each procedure takes 1 clock cycle, cpi -> 3









## 6.4 The ARM9 Processors



## 6.5 The 5-Stage Pipelining in ARM9 Processors

### Fetch
- Fetch instruction from memory and placed in the instruction pipeline

### Decode
- the instruction is decoded and register operands read from the register file. There are 3 operand read ports in the register file, so most ARM instructions can source all their operands in one cycle

### Execute: 
- an operand is shifted and the ALU result generated. If the instruction is a load or store, the memory address is computed in the ALU

### Buffer/Data: 
- data memory is accessed if required. Otherwise the ALU result is simply buffered for one clock cycle to give the same pipeline flow for all instructions

### Write-back: 
- Results generated by the instruction are written back to the register file, including any data loaded from memory.

### Example of 5-stage pipeline
![[Pipelines stages.png]]

- k -> number of pipeline stages
- speed up = performance of pippeline computer/performance of sequential computer
- k $\propto$ speed up




## 6.6 The ARM11 Processors




## 6.7 Latest Development of ARM Processors
: google la dllm

